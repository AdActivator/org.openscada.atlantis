<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://docbook.org/xml/4.4/docbookx.dtd" []>

<chapter id="master"><title>Master Server</title>
	<para>
  		This section describes the <quote>master server</quote> which actually
  		is an <trademark>OSGi</trademark> container that is configured with
  		several bundles that provide some common <acronym>SCADA</acronym>
  		functionality. Using <trademark>OSGi</trademark> bundled and functionality
  		can be added, removed, updated and reconfigured on the fly as needed. The
  		<quote>master server</quote> itself is a specific set up which contains bundles
  		that provide <acronym>SCADA</acronym> functionality.
  	</para>
  	
  	<sect1><title>Master Server Overview</title>
  	
  	<para>
  	 	As seen in illustration <xref linkend="master_overview_illustration"/> the master server gets its
  	 	input from one or more DA hives, processes the data and provides the result using several
  	 	different interfaces.
  	 	 
  	 	 <figure id="master_overview_illustration"><title>Master Server Overview</title>
		<mediaobject>
			<imageobject>
				<imagedata fileref="images/500-master/master_overview.pdf" format="PDF" scalefit="1"/>
			</imageobject>
			<imageobject>
				<imagedata fileref="images/500-master/master_overview.png" format="PNG" scalefit="1"/>
			</imageobject>
		</mediaobject></figure>
  	 	
  	 	The main processing pipeline is data coming in from the device drivers (<quote>DA hives</quote>),
  	 	being processes and then provided again using the <acronym>DA</acronym> interface. The master
  	 	server internally uses <quote>data sources</quote> instead of <quote>data items</quote>. Basically
  	 	the idea is the same, but there are some technical differences needed for the master server
  	 	in order to better handle data when it is processes inside the master server. So on both ends
  	 	of the master server there are converters from a data item to a data source and back. On the input
  	 	side the master server has a connection to a DA hive and, in most cases, several subscriptions to
  	 	data items. The data provided by these data items is received by the data sources which pass on
  	 	the information to internal subscribers. At the end of the processing pipeline the last data
  	 	source will again be converted to a data item so that it can be provided to other DA clients using
  	 	the standard <trademark>OpenSCADA</trademark> interfaces.   
  	</para>
  	<para>
  		Beside the source and target data source, explained in the previous paragraph, there can be one or
  		more data sources in between which manipulate data while processing. The most common processing
  		data source is the <quote>master item</quote> which allows to add several <quote>master handlers</quote>
  		the manipulate data in one step. While each data source has its own definition of processing and
  		passing on data the master item will trigger all master handlers at once before passing on
  		information. So a master handler is like a processing data source acquires its input from another
  		data source. The main difference between these two is that the master handler is limited to
  		the trigger of the master item, whereas the data source can delay or aggregate input data as it likes.
  		One the other side a master item handler it much more focused on one data source (the master item)
  		and therefore reduces <quote>data source clutter</quote> in the master server.
  	</para>
  	<para>
  		Data sources and master handlers can of course alter data provided by the devices or intercept
  		and change write requests. An easy example is the scaling master handler. It simply changes the
  		primary value received from the originating data source and scales it according to actual settings.
  		In addition is extends the secondary values by adding the original source value and the current
  		scaling factor. Write requests are intercepted and specific attribute writes are filtered out
  		and applied to the current settings of the scaling handler.
  	</para>
  	<para>
  		A second example for a master handler is the level alarm. It checks the primary value and generates
  		a level alarm according to current settings. The result is provided to the A&amp;E system which
  		might generate an alarm condition and log an event. The current alarm condition is then feed back
  		into the secondary values so the further DA clients can read the current level condition by
  		evaluating the secondary values. This might let a process visualization let the value appear in red
  		if it reached a limit.  
  	</para>
  	<para>
  		Since one data source and master handler might depend of results of others the order of processing
  		is important. For data sources this is a matter of configuration. Each data source that processes
  		data gets a source data source configured. This configuration makes up a chain that defines the
  		order of processing. Master item handlers on the other side have a priority. So the master item
  		will call the handlers in that defined order. 
  	</para>
  	</sect1>
  	
  	<sect1><title>Available data sources</title>
  		<para>To be written...</para>
  	</sect1>
  	
  	<sect1><title>Available master handlers</title>
  		<para>To be written...</para>
  	</sect1>
  	
  	<sect1><title>Setting up a master server</title>
  		<para>To be written...</para>
  	</sect1>
  	
  	<sect1><title>Configuring a master server</title>
  		<para>To be written...</para>
  	</sect1>

</chapter>